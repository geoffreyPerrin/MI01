\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
 \usepackage{listings}
 \usepackage{color}
 \usepackage{fancyhdr}
 \usepackage{graphicx}
\pagestyle{fancy}

 \lhead{Geoffrey PERRIN \\ Océane DUBOIS}
 \rhead{MI01 - TP02 : VHDL séquentiel}
 \rfoot{}



\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=vhdl,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

 
%Gummi|065|=)
\title{\textbf{TP02 - VHDL séquentiel}
\author{Geoffrey PERRIN \\ Océane DUBOIS\\}
\date{}}

\begin{document}

\maketitle

\newpage

\section{Exercice préliminaire}

Voici le code d'un diviseur de fréquence : 
\begin{lstlisting}
entity blinker is
	port(Clk100MHz, PB_0 : in bit; --on utilise l'horloge 100MHz en signal d'entree
		LED_0 : out bit);
end blinker;

architecture Behavioral of blinker is
	alias reset is PB_0; --PB\_0 est defini comme le signal de reset
	signal clk_out : bit := '0'; -- signal d'horloge apres division
	constant clock_divisor : integer := 100000000; --constante de division pour un signal a 1Hz
	begin
		clock_divider : process(Clk100Mhz, reset)
		variable c : integer range 0 to clock_divisor - 1 := 0;
		begin
		if reset = '1' then -- si on declanche le reset on recommence le cycle de l'horloge a 0
			c := 0;
			clk_out <= '0';
		elsif Clk100MHz'event and Clk100MHz = '1' then --si le signal Clk100MHz est sur un front montant
			if c < (clock_divisor - 1) / 2 then --
				c := c + 1;
				clk_out <= '0';
			elsif c = (clock_divisor - 1) then
				c := 0;
				clk_out <= '0';
		else
			c := c + 1;
			clk_out <= '1';
		end if;
	end if;
	end process;
-- Sortie sur la LED
LED_0 <= clk_out;
end Behavioral;
\end{lstlisting}

Dans ce code, on définit d'abord une entité "blinker", consituté de 2 ports d'entrée : Clk100MHz, PB\_0 et une sortie LED\_0.

Puis dans l'architecture, on définit un alias pour PB\_0 qui sera désomais appelé reset. On définit un nouveau signal de type bit, appelé clk\_out qui est initialisé à 0.  Et une constante de type entier nommé clock\_divisor initialisé à 100000000. 

Puis on déclare un process donc la liste de signaux de sensibilité est composée des signaux Clk100Mhz et reset.C'est donc un reset asynchrone.  

Dans le process si le reset est activé, on met la variable c à 0 et le signal clock\_out à 0. Si le signal Clk100MHz est sur un front montant et que la variable c est inferieur à (100000000-1)/2 =49999999,5 alors on incrémente la variable c et le signal clock\_out est mis à 0. Si c = 99999999 on met c à 0 et clv\_out à 0. Dans tous les autres cas on incrémente c et on met clk\_out.

A la fin du process on égalise clk\_out sur LED\_0.


\section{Feu de circulation}

Dans cet exercices on cherchera à implémenter un contrôleur de circulation, permettant de réguler la circulation d'un croisement à 2 axes principaux. 

Le feu rouge dure 10 secondes et le feu orange 2 secondes. Le feu vert doit donc durer 8 secondes. Puisqu'il faut que Trouge = Tvert + Torange. 

La plus petite unité de temps utilisée est donc 2 secondes (Tsync), on  peut donc utiliser une fréquence d'horloge de f=1/Tsync=0,5Hz

On nomme les 2 axes A et B qui sont perpendiculaires. Lorsque le feu de l'axe A est au rouge, le feu de l'axe B doit être vert puis passer au orange. Puis le feu de l'axe B passe enfin au rouge, et le feu de l'axe A passe au vert puis 8 secondes plus tard au orange. 

On réalise un modélisation à partir d'un machine à états. 

On utilisera la valeur 1 pour signaler un feu rouge, 2 pour le feu orange et 3 pour le feu vert. 

\subsection{Code VHDL}
\begin{lstlisting}
ENTITY feu IS
	PORT(LED_3210, LED_7654 : OUT INTEGER);
END feu

ARCHITECTURE Behavioural OF feu IS
BEGIN 
PROCESS (


\end{lstlisting}




\end{document}
